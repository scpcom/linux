/**
 * @file 	tpc_helper.h
 * @brief	Basic strcuture declaration header file for 
 *		3rd-party copy command helper code
 *
 * @author	Adam Hsu
 * @date	2012/06/04
 *
 */
#ifndef __TPC_HELPER_H__
#define __TPC_HELPER_H__

#include <linux/types.h>
#include <linux/kernel.h>
#include <linux/dma-mapping.h>
#include <scsi/scsi.h>
#include "vaai_target_struc.h"
#include "target_general.h"
#include "tpc_def.h"

/**/
//#define DBG_ROD_FUNC



/**/
#if defined(DBG_ROD_FUNC)
#define DBG_ROD_PRINT(fmt, args...)         printk(KERN_DEBUG fmt, ##args)
#define DBG_ROD_BW_PRINT(fmt, args...)      printk(KERN_DEBUG fmt, ##args)
#define DBG_ROD_FW_PRINT(fmt, args...)      printk(KERN_DEBUG fmt, ##args)
#define DBG_ROD_TIMER_PRINT(fmt, args...)   printk(KERN_DEBUG fmt, ##args)
#else
//#define DBG_ROD_PRINT(fmt, args...)         printk(KERN_DEBUG fmt, ##args)
//#define DBG_ROD_BW_PRINT(fmt, args...)      printk(KERN_DEBUG fmt, ##args)
//#define DBG_ROD_FW_PRINT(fmt, args...)      printk(KERN_DEBUG fmt, ##args)
#define DBG_ROD_PRINT(fmt, args...)
#define DBG_ROD_BW_PRINT(fmt, args...)
#define DBG_ROD_FW_PRINT(fmt, args...)
#define DBG_ROD_TIMER_PRINT(fmt, args...)
#endif


/* TPC OBJ STATUS */
typedef enum{
    O_STS_ALLOCATED_BUT_NOT_ALIVE    = 0,   /* intial value */
    O_STS_ALIVE                         ,   /* obj is in the obj list */ 
    O_STS_FREE_BY_TPC_TIMER             ,   /* obj will be free by tpc obj timer */
    O_STS_FREE_BY_PROC                  ,   /* obj will be free by other procedure */

    /* No expired status for obj cause of it will be deleted while obj timer is fired */
    O_STS_DELETED                       ,   /* set while the obj will be deleted */
}OBJ_STS;

/* OBJ TOKEN STATUS */
typedef enum{
    O_TOKEN_STS_NOT_ALLOCATED_AND_NOT_ALIVE  = 0, /* intial value */
    O_TOKEN_STS_ALLOCATED_BUT_NOT_ALIVE  ,   /* token was allocated but not record in token_data */
    O_TOKEN_STS_ALIVE                    ,   /* token was allocated and record in token_data */
    O_TOKEN_STS_FREE_BY_TOKEN_TIMER      ,   /* token will be free by token timer */
    O_TOKEN_STS_FREE_BY_PROC             ,   /* token will be free by other procedure */
    O_TOKEN_STS_EXPIRED                  ,   /* token was expired */
    O_TOKEN_STS_CANCELLED                ,   /* token was cancelled by copy manager */
    O_TOKEN_STS_DELETED                  ,   /* token was deleted by ap client */
}OBJ_TOKEN_STS;


/** 
 * @struct
 * @brief
 * @note
 */
#define CMD_ASKED_NOTHING        0
#define CMD_ASKED_BY_ABORT       1

/* The CUR_STATUS doesn't relate to copy operation status */
typedef enum{
    T_CMD_NOT_START         = 0 ,
    T_CMD_IS_STARTING_IN_FG ,
    T_CMD_IS_STARTING_IN_BG ,
    T_CMD_COMPLETED_W_ERR   ,
    T_CMD_COMPLETED_WO_ERR  ,
    T_CMD_WAS_ABORTED       ,
    MAX_T_CMD_STATUS        ,
}T_CMD_STATUS;

/* macro for T_CMD_STATUS */
#define T_CMD_STS_IS_NOT_START(status)          ((status == T_CMD_NOT_START) ? 1 : 0)
#define T_CMD_STS_IS_START_FG(status)           ((status == T_CMD_IS_STARTING_IN_FG) ? 1 : 0)
#define T_CMD_STS_IS_START_BG(status)           ((status == T_CMD_IS_STARTING_IN_BG) ? 1 : 0)
#define T_CMD_STS_WAS_COMPLETED_W_ERR(status)   ((status == T_CMD_COMPLETED_W_ERR) ? 1 : 0)
#define T_CMD_STS_WAS_COMPLETED_WO_ERR(status)  ((status == T_CMD_COMPLETED_WO_ERR) ? 1 : 0)
#define T_CMD_STS_WAS_ABORT(status)             ((status == T_CMD_WAS_ABORTED) ? 1 : 0)


typedef enum{
    TPC_LID_NOT_CP_CMD      = 0,
    TPC_LID_GET_OK          = 1,
    TPC_LID_NO_ID           = 2,
    MAX_TP_LID                ,
}TPC_LID;

typedef enum{
    TPC_NOT_CP_CMD          = 0,
    TPC_CP_OP               = 1,
    TPC_CP_MONITOR          = 2,
    TPC_CP_MANAGEMENT       = 3,
    TPC_CP_NO_TYPE          = 4,
    MAX_TPC_CMD_TYPE           ,
}TPC_CMD_TYPE;

/* The OBJ_DATA_TYPE will indicate what kind of data will be kept by tpc obj */
typedef enum{
    O_DATA_TYPE_NONE        = 0,  /* no any data generated by 3rd-party copy command */
    O_DATA_TYPE_ROD            ,  /* the rod (include rod token) generated by 3rd-party copy command */
    O_DATA_TYPE_HOLD_DATA      ,  /* the hold data generated by 3rd-party copy command */
}OBJ_DATA_TYPE;

/**/
#define IS_NONE_TYPE(type)          ((type == O_DATA_TYPE_NONE) ? 1 : 0)
#define IS_ROD_TYPE(type)           ((type == O_DATA_TYPE_ROD) ? 1 : 0)
#define IS_HOLD_DATA_TYPE(type)     ((type == O_DATA_TYPE_HOLD_DATA) ? 1 : 0)


/** 
 * @struct
 * @brief
 */
typedef struct _tpc_rec_data{
    TPC_DESC_TYPE_CODE DescCode;
    u8 *pu8TpcDesc;
} __attribute__ ((packed)) TPC_REC_DATA;

typedef int
(*GET_DESC_LEN)(
    IN OUT u16 *len
    );

typedef int
(*BUILD_DESC)(
    IN LIO_SE_CMD *cmd,
    IN TPC_REC_DATA *data
    );

/** 
 * @struct
 * @brief
 */
typedef struct build_tpc_desc{
    TPC_DESC_TYPE_CODE  DescCode;
    GET_DESC_LEN        GetDescLen;
    BUILD_DESC          BuildDesc;
} __attribute__ ((packed)) BUILD_TPC_DESC;


/** 
 * @struct
 * @brief
 */
typedef struct _rod_type_table{
    u32     rod_type;
    bool    end_table;

    /*
     * TokenOut - 1 : Indicate the copy manager supports the generation and 
     *                returning of ROD tokens that have ROD type indicated by 
     *                ROD_TYPE filed by one or more commands that the copy 
     *                manager processes
     *
     * TokenOut - 0 : Indicate the copy manager does NOT supports the generation
     *                and returning of ROD tokens that have ROD type indicated by 
     *                ROD_TYPE filed
     */
    
    u32     token_out;

    /*
     * TokenIn - 1 : Indicate the copy manager supports the receipt of ROD tokens
     *               that have ROD type indicated by ROD_TYPE filed by one or more
     *               commands that the copy manager processes
     *
     * TokenIn - 0 : Indicate the copy manager does NOT supports the receipt of
     *               ROD tokens that have ROD type indicated by ROD_TYPE filed
     */
    u32     token_in;

    /*
     * EcpyInt - 1 : Support the ROD type indicated by ROD_TYPE filed for internal
     *               RODs in the EXTENDED COPY command
     *
     * EcpyInt - 0 : Does NOT Support the ROD type indicated by ROD_TYPE filed 
     *               for internal RODs in the EXTENDED COPY command
     */
    u32     ecpy_int_bit;

    /**/
    u32     preference_indication;
} ROD_TYPE_TABLE;

/** 
 * @struct
 * @brief
 */
typedef struct _cscd_id_table{
    u16     u16Ids;
    u8      u8IsEndTable;
} __attribute__ ((packed)) CSCD_ID_TABLE;



/** 
 * @struct BLK_RANGE_OBJ
 * @brief
 * @note 
 *
 */
#define R_STATUS_NOT_USED           0
#define R_STATUS_TRANSFER_USED      1
#define R_STATUS_TRUNCATE_USED      2

typedef struct blk_range_data{
    struct list_head    b_range_data_node;
    sector_t            lba;
    u32                 nr_blks;

    /* Please refer the R_STATUS_XXX */
    u32                 curr_status;
    u32                 next_status;
}BLK_RANGE_DATA;


/**/
typedef struct tpc_obj{
	LIO_SE_PORTAL_GROUP	*se_tpg;
	LIO_SE_LUN		*se_lun;
	struct list_head	o_node;

	/* If this tpc command will produce any data like ROD or HOLD data,
	 * it will be record into this data_list
	 */
	struct list_head	o_data_list;
	struct timer_list	o_timer;	// timer for entire tpc obj
	struct timer_list	o_token_timer;	// timer for rod token timer
	OBJ_STS			o_status;
	OBJ_TOKEN_STS		o_token_status;
	spinlock_t		o_status_lock;
	spinlock_t		o_token_status_lock;
	spinlock_t		o_data_lock;
	spinlock_t		o_transfer_count_lock;

	/* 2014/08/17, adamhsu, redmine 9007 */
	spinlock_t		o_ref_count_lock;
	spinlock_t		o_token_ref_count_lock;

	atomic_t		o_ref_count;
	atomic_t		o_token_ref_count;

	/* (1) If this tpc command will produce rod token, it will be recorded
	 *     into o_data field 
	 * (2) Perhaps, it can be used to be other purpose in the future
	 */
	void			*o_token_data;        

	/* --------------------------------------------------------
	 * --- Basic information for copy-operation data record ---
	 * --------------------------------------------------------
	 */

	/* The unit of transfer_count field is block-based for
	 * RECEIVE ROD TOKEN INFORMATION command of SBC specification currently.
	 * (SBC3R31, page 156)
	 */
	u64			transfer_count;
	u16			segs_processed;
	u16			op_counter;
	u8			cp_op_status;

	/* Status about the tpc cmd that originated copy operation. This will be 
	 * set to scsi status code. Please refer the SAM_STAT_XXXX in
	 * include\scsi\scsi.h
	*/
	u8			completion_status;
	u8			reserved0[2];
	u8			sense_data[ROD_SENSE_DATA_LEN];

	/* ------------------------------------------
	 * --- Basic information for tpc obj data ---
	 * ------------------------------------------
	 */

	/* FIXED ME */
	char			isid[PR_REG_ISID_LEN];
	char			tiqn[TARGET_IQN_NAME_LEN];
	SUBSYSTEM_TYPE		backend_type;

	/* FIXED ME */
	unsigned long		create_time;

	/* please refer the OBJ_DATA_TYPE enum in tpc_helper.h */
	OBJ_DATA_TYPE		o_data_type;
	u32			dev_bs_order;   /* i.e. 2^9 = 512 or 2^12=4096 */
	u32			list_id;
	u16			op_sac;
	u16			pg_tag;

} __attribute__ ((packed)) TPC_OBJ;



typedef struct tpc_track_data{
	spinlock_t		t_cmd_asked_act_lock;
	spinlock_t		t_status_lock;
	spinlock_t		t_count_lock;

	/* 2014/08/17, adamhsu, redmine 9007 */
	spinlock_t		t_ref_count_lock;	

	atomic_t		t_ref_count;
	int			t_cmd_status;
	int			t_cmd_asked;
	int			t_cmd_type;

	/* FIXED ME !!
	 * the unit of transfer_count field is block-based for
	 * RECEIVE ROD TOKEN INFORMATION command of SBC specification currently.
	 * (SBC3R31, page 156)
	 */
	u64			t_transfer_count;
	u16			t_segs_processed;
	u16			t_op_counter;
	u8			t_sense_data[ROD_SENSE_DATA_LEN];
} __attribute__ ((packed)) TPC_TRACK_DATA;


/**/
typedef struct __wbt_obj{
	TPC_OBJ			*s_obj;
	TPC_OBJ			*d_obj;

	/**/
	u64 			data_bytes;	/* byte counts written to dest */
	u64 			s_off_rod;	/* byte off of source ROD */
	sector_t		d_lba;
	TPC_TRACK_DATA		*t_data;	/* track data of cmd sent to dest */
	unsigned long		timeout;
	ERR_REASON_INDEX	err;

	/**/
	struct scatterlist	*sg_list;
	u32			sg_nents;
	u32			sg_total_bytes;
}WBT_OBJ;

/*****************************************
 *
 * macro for TPC OBJ STATUS
 *
 ******************************************/
#define OBJ_STS_IS_ALLOCATED_BUT_NOT_ALIVE(o_status) \
    ((o_status == O_STS_ALLOCATED_BUT_NOT_ALIVE) ? 1 : 0)

#define OBJ_STS_ALIVE(o_status) \
    ((o_status == O_STS_ALIVE) ? 1 : 0)

#define OBJ_STS_FREE_BY_TPC_TIMER(o_status) \
    ((o_status == O_STS_FREE_BY_TPC_TIMER) ? 1 : 0)

#define OBJ_STS_FREE_BY_PROC(o_status) \
    ((o_status == O_STS_FREE_BY_PROC) ? 1 : 0)

#define OBJ_STS_DELETED(o_status) \
    ((o_status == O_STS_DELETED) ? 1 : 0)


/*****************************************
 *
 * macro for TPC TOKEN STATUS 
 *
 ******************************************/
#define TOKEN_STS_NOT_ALLOCATED_AND_NOT_ALIVE(t_status) \
    ((t_status == O_TOKEN_STS_NOT_ALLOCATED_AND_NOT_ALIVE) ? 1 : 0)

#define TOKEN_STS_ALLOCATED_NOT_ALIVE(t_status) \
    ((t_status == O_TOKEN_STS_ALLOCATED_BUT_NOT_ALIVE) ? 1 : 0)

#define TOKEN_STS_ALIVE(t_status) \
    ((t_status == O_TOKEN_STS_ALIVE) ? 1 : 0)

#define TOKEN_STS_FREE_BY_TOKEN_TIMER(t_status) \
    ((t_status == O_TOKEN_STS_FREE_BY_TOKEN_TIMER) ? 1 : 0)

#define TOKEN_STS_FREE_BY_PROC(t_status) \
    ((t_status == O_TOKEN_STS_FREE_BY_PROC) ? 1 : 0)

#define TOKEN_STS_EXPIRED(t_status) \
    ((t_status == O_TOKEN_STS_EXPIRED) ? 1 : 0)

#define TOKEN_STS_CANCELLED(t_status) \
    ((t_status == O_TOKEN_STS_CANCELLED) ? 1 : 0)

#define TOKEN_STS_DELETED(t_status) \
    ((t_status == O_TOKEN_STS_DELETED) ? 1 : 0)


/**/
#define SAME_ID_OP_SAC(s_id, d_id, s_opsac, d_opsac) \
    ((s_id == d_id) && (s_opsac == d_opsac))

#define IS_TPC_CMD_TYPE(type) \
    ((type == TPC_CP_OP) || (type == TPC_CP_MONITOR) || (type == TPC_CP_MANAGEMENT))

/**/
/* 20140630, adamhsu, redmine 8826 */
int __tpc_do_zero_rod_token_w(IN GEN_RW_TASK *task);

int __tpc_do_rw(IN GEN_RW_TASK *task);
int __tpc_is_tpg_v_lun0(IN LIO_SE_CMD *se_cmd);
int __tpc_is_lun_receive_stop(IN LIO_SE_CMD *se_cmd);
int __tpc_is_se_tpg_actived(IN LIO_SE_CMD *se_cmd);
int __is_se_tpg_actived(IN LIO_SE_PORTAL_GROUP *se_tpg);

/**/
TPC_OBJ *__tpc_do_alloc_obj(IN LIO_SE_CMD *se_cmd);

int __tpc_do_alloc_token_data(
    IN LIO_SE_CMD *se_cmd,
    IN TPC_OBJ *obj,
    IN u32 token_type,
    IN u16 token_size,
    IN OUT ERR_REASON_INDEX *err
    );

int __tpc_get_iname_and_isid_by_se_sess(
    IN LIO_SE_SESSION *se_sess,
    IN char *i_name,
    IN u64 *isid
    );

int __tpc_get_isid_by_se_td(IN LIO_SE_CMD *se_cmd, IN OUT char *isid);
int __tpc_get_tiqn_and_pg_tag_by_se_td(IN LIO_SE_CMD *se_cmd, IN char *tiqn,
	IN u16 *tag);

TPC_OBJ *__tpc_get_obj_by_token_data(IN u8 *token_id, IN u8 *lu_designator,
	IN u8 *target_dev_desc,	IN OUT ERR_REASON_INDEX *err);

TPC_OBJ *__tpc_get_obj_by_id_opsac(IN LIO_SE_PORTAL_GROUP *se_tpg,
	IN LIO_SE_CMD *se_cmd);

void __tpc_build_512b_token_data(IN LIO_SE_CMD *se_cmd,
	IN TPC_OBJ *obj);

void __tpc_build_obj_sense_data(IN TPC_OBJ *obj, IN ERR_REASON_INDEX err,
	IN u8 asc, IN u8 ascq);

int __tpc_set_obj_completion_status(IN TPC_OBJ *obj);
int __tpc_set_obj_op_counter(IN TPC_OBJ *obj);


/**/
void __tpc_obj_node_lock_add(IN TPC_OBJ *tpc_obj);
void __tpc_obj_node_add(IN TPC_OBJ *tpc_obj);
void __tpc_obj_node_del(IN TPC_OBJ *obj);

/* 2014/08/17, adamhsu, redmine 9007 */
void __tpc_td_ref_count_lock_inc(IN TPC_TRACK_DATA *td);
void __tpc_td_ref_count_lock_dec(IN TPC_TRACK_DATA *td);
void __tpc_obj_ref_count_lock_inc(IN TPC_OBJ *obj);
void __tpc_obj_ref_count_lock_dec(IN TPC_OBJ *obj);
void __tpc_token_ref_count_lock_inc(IN TPC_OBJ *obj);
void __tpc_token_ref_count_lock_dec(IN TPC_OBJ *obj);


void __tpc_update_obj_transfer_count_lock(IN TPC_OBJ *obj, IN u64 count);
void __tpc_update_obj_status_lock(IN TPC_OBJ *obj, IN OBJ_STS status);

void __tpc_update_obj_token_status_lock(IN TPC_OBJ *obj, IN OBJ_TOKEN_STS status);
OBJ_STS __tpc_get_obj_status_lock(IN TPC_OBJ *obj);
OBJ_TOKEN_STS __tpc_get_obj_token_status_lock(IN TPC_OBJ *obj);
int __tpc_is_token_expired(IN OBJ_TOKEN_STS token_status);
int __tpc_is_token_cancelled(IN OBJ_TOKEN_STS token_status);
int __tpc_is_token_deleted(IN OBJ_TOKEN_STS token_status);
int __tpc_is_token_invalid(IN TPC_OBJ *obj, IN OUT ERR_REASON_INDEX *err);
sector_t __tpc_get_nr_blks_by_s_obj(IN TPC_OBJ *obj, IN bool skip_truncate);
u64 __tpc_get_nr_bytes_by_s_obj(IN TPC_OBJ *obj, IN bool skip_truncate);
void __build_big_endian_data(IN u8 *to, IN u8 *from, IN size_t size);

BLK_RANGE_DATA * __tpc_get_rod_loc_by_rod_off(IN TPC_OBJ *s_obj,
	IN OUT u32 *bdr_off, IN u64 off_to_rod);

void __tpc_update_br_status(IN TPC_OBJ *obj);

/**/
T_CMD_STATUS __tpc_get_t_cmd_status(IN TPC_TRACK_DATA *data);

void __tpc_update_t_cmd_status(IN TPC_TRACK_DATA *data,
	IN T_CMD_STATUS status);

void __tpc_update_t_cmd_transfer_count(IN TPC_TRACK_DATA *data,
	IN sector_t nr_blks);

sector_t __tpc_get_t_cmd_transfer_count(IN TPC_TRACK_DATA *data);
int __tpc_is_same_id_cscd_desc_cmd_obj(IN LIO_SE_CMD *se_cmd, IN TPC_OBJ *obj);

int __tpc_is_same_tiqn_and_pg_tag(IN char *s_tiqn, IN char *d_tiqn,
	IN u16 s_tag, IN u16 d_tag);

int __tpc_is_same_initiator_info(IN char *s_i_name, IN char *d_i_name,
	IN u64 s_isid, IN u64 d_isid);

int __tpc_is_same_i_t_nexus_func1(IN TPC_OBJ *obj, IN LIO_SE_CMD *se_cmd);
int __tpc_is_same_i_t_nexus_func2(IN LIO_SE_CMD *s_se_cmd, IN LIO_SE_CMD *d_se_cmd);
int __tpc_get_tiqn_and_pg_tag_by_se_cmd(IN LIO_SE_CMD *se_cmd, IN char *tiqn,
	IN u16 *tag);

int __tpc_get_isid_by_se_cmd(IN LIO_SE_CMD *se_cmd, IN u32 size, 
	IN OUT char *isid);

/* Functions listed below will be export */
void tpc_release_obj_for_se_tpg(IN LIO_SE_PORTAL_GROUP *se_tpg);
TPC_LID tpc_get_list_id(IN LIO_SE_CMD *se_cmd, IN u32 *list_id);
int tpc_is_to_cancel_rod_token_func1(IN LIO_SE_CMD *se_cmd);
int tpc_is_to_cancel_rod_token_func2(IN LIO_SE_CMD *se_cmd);
void __tpc_setup_obj_timer(IN TPC_OBJ *obj);
void __tpc_free_obj_timer(IN unsigned long arg);

/**/
int __chk_valid_supported_rod_type(IN u32 rod_type);
u32 __get_min_rod_token_info_param_len(IN void);
int tpc_is_in_progress(IN LIO_SE_CMD *cmd);
BLK_RANGE_DATA * __create_blk_range(IN void);

void __tpc_free_obj_node_data(IN struct list_head *data_list);
u16 __tpc_get_desc_counts(IN u16 len);
sector_t __tpc_get_total_nr_blks_by_desc(IN BLK_DEV_RANGE_DESC *start,
	IN u16 desc_counts);

u16 __tpc_get_max_supported_blk_dev_range(IN LIO_SE_CMD *se_cmd);
int tpc_populate_token(IN LIO_SE_TASK * se_task);
int tpc_write_by_token(IN LIO_SE_TASK * se_task);
int tpc_receive_rod_token_info(IN LIO_SE_TASK * se_task);
void tpc_free_track_data(IN LIO_SE_CMD *se_cmd);
int tpc_emulate_evpd_8f(IN LIO_SE_CMD *pSeCmd, IN u8 *pu8Buff);

/**/
extern struct list_head *tpc_get_tpg_list_var(void);
extern void *tpc_get_tpg_lock_var(void);


/**/
extern ROD_TYPE_TABLE           gRodTypeTable[];
extern CSCD_ID_TABLE            gSupportedCSCDIdsTable[];
extern ERR_REASON_TABLE         gErrReasonTable[MAX_ERR_REASON_INDEX];


#endif /* __TPC_HELPER_H__ */

